{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"usu-optt-forms A collection of online web forms to faciliate easy record keeping on USU OPTT students. Requirements This project is built using Node via npm . Make sure you have this installed, then run git clone https://github.com/jarenglenn/usu-optt-forms.git cd usu-optt-forms npm install Development To start up a development server, run npm run dev Then open app/index.html to view your changes. Deployment To build the project, run the prepareDist deployment script. python prepareDist.py Note: This script runs switches to each form using app/webpack/currentForm.ts and builds the project for each one via npm run build . Additionally it creates a production.zip archive for ease of use. You'll then need to SSH into USU's servers and replace the current files with the new versions stored in dist/structure . Contact your supervisor to get access.","title":"Home"},{"location":"#usu-optt-forms","text":"A collection of online web forms to faciliate easy record keeping on USU OPTT students.","title":"usu-optt-forms"},{"location":"#requirements","text":"This project is built using Node via npm . Make sure you have this installed, then run git clone https://github.com/jarenglenn/usu-optt-forms.git cd usu-optt-forms npm install","title":"Requirements"},{"location":"#development","text":"To start up a development server, run npm run dev Then open app/index.html to view your changes.","title":"Development"},{"location":"#deployment","text":"To build the project, run the prepareDist deployment script. python prepareDist.py Note: This script runs switches to each form using app/webpack/currentForm.ts and builds the project for each one via npm run build . Additionally it creates a production.zip archive for ease of use. You'll then need to SSH into USU's servers and replace the current files with the new versions stored in dist/structure . Contact your supervisor to get access.","title":"Deployment"},{"location":"notes/","text":"","title":"General Notes"},{"location":"rubrics/","text":"The .json files stored in rubrics serve as a way to store large amounts of data without simply just putting into React itself. Rubrics Rubrics are imported in FormData and used to provide rubric data to each of the forms. This is used, mostly, by the pages/data/Rubric component. It loops over the rubric provided and generates the rubric scoring page. Other JSON Data There are a couple json files stored here that are not rubrics, however: practicumChecklist is imported in pages/PracticumChecklist and components/pdfDataChecklist to generate the checklist page and the report for the checklist page, respectively. notebookChecks.json is imported in notebookCheckUtils to provide a util function used to get the content of a notebook check in defaults and notebookChecksSlice .","title":"Rubrics"},{"location":"rubrics/#rubrics","text":"Rubrics are imported in FormData and used to provide rubric data to each of the forms. This is used, mostly, by the pages/data/Rubric component. It loops over the rubric provided and generates the rubric scoring page.","title":"Rubrics"},{"location":"rubrics/#other-json-data","text":"There are a couple json files stored here that are not rubrics, however: practicumChecklist is imported in pages/PracticumChecklist and components/pdfDataChecklist to generate the checklist page and the report for the checklist page, respectively. notebookChecks.json is imported in notebookCheckUtils to provide a util function used to get the content of a notebook check in defaults and notebookChecksSlice .","title":"Other JSON Data"},{"location":"stateManagement/","text":"Slices A \"slice\" is the terminology used by Redux Toolkit to control state. It provides the actions and defaults for each of your states. In this app these slices are stored in app/webpack/slices . Actions For example, on the rubric state, the only actions needed are setRubricScore , setRubricComment , and resetRubric . These are provided and easily seen in the rubricSlice file. These can be accessed by importing them and using the useAppDispatch hook from hooks/hooks.ts . import { useAppDispatch } from \"hooks/hooks\" ; import { resetFormInfo } from \"slices/formInfoSlice\" ; const Component = () => { const dispatch = useAppDispatch (); dispatch ( resetFormInfo ()); ... } Initial State However, slices also allow granular control of the initial state of the application, as also seen in the rubric slice. The initial state is not known at the beginning; instead it generates the initial state via getInitialState which loops over the rubric and creates an object representing it. Store Stores, as their name suggests, are what actually hold the state. This app's store store.ts imports each of the slices and saves them to the store. Then, state can be accessed by importing the useAppSelector in hooks/hooks.ts and a slice's selector like the example shown. import { useAppSelector } from \"hooks/hooks\" ; import { selectFormInfo } from \"slices/formInfoSlice\" ; const Component = () => { const formInfo = useAppSelector ( selectFormInfo ); ... } Note that redux-persist is used in store.ts to ensure data is saved between sessions. This also allows each form to have its own storage via the key: currentForm config parameter so multiple forms can be opened at once without overwriting each other.","title":"State Management"},{"location":"stateManagement/#slices","text":"A \"slice\" is the terminology used by Redux Toolkit to control state. It provides the actions and defaults for each of your states. In this app these slices are stored in app/webpack/slices .","title":"Slices"},{"location":"stateManagement/#actions","text":"For example, on the rubric state, the only actions needed are setRubricScore , setRubricComment , and resetRubric . These are provided and easily seen in the rubricSlice file. These can be accessed by importing them and using the useAppDispatch hook from hooks/hooks.ts . import { useAppDispatch } from \"hooks/hooks\" ; import { resetFormInfo } from \"slices/formInfoSlice\" ; const Component = () => { const dispatch = useAppDispatch (); dispatch ( resetFormInfo ()); ... }","title":"Actions"},{"location":"stateManagement/#initial-state","text":"However, slices also allow granular control of the initial state of the application, as also seen in the rubric slice. The initial state is not known at the beginning; instead it generates the initial state via getInitialState which loops over the rubric and creates an object representing it.","title":"Initial State"},{"location":"stateManagement/#store","text":"Stores, as their name suggests, are what actually hold the state. This app's store store.ts imports each of the slices and saves them to the store. Then, state can be accessed by importing the useAppSelector in hooks/hooks.ts and a slice's selector like the example shown. import { useAppSelector } from \"hooks/hooks\" ; import { selectFormInfo } from \"slices/formInfoSlice\" ; const Component = () => { const formInfo = useAppSelector ( selectFormInfo ); ... } Note that redux-persist is used in store.ts to ensure data is saved between sessions. This also allows each form to have its own storage via the key: currentForm config parameter so multiple forms can be opened at once without overwriting each other.","title":"Store"},{"location":"tools/","text":"This page serves as a guide to the tools and packages used to create the forms. Documentation for each of these will not be provided as their individual documentation will be much more thorough and helpful than anything written here. Language This project was built from the ground up in TypeScript rather than JavaScript. This makes some aspects of development more tedious, but as projects grow larger they become easier to deal with especially when it comes to state management. Most other packages used in this project have great Typescript support (with the exception of jspdf ). Framework This project uses React which is a fantastic framework that is well suited to this type of application. These fairly complex data-heavy forms are extremely easy to manage with React's state management system. Datepicker Note that React Datepicker provides the date selection component used on the Home page. State Management Redux Toolkit is used for almost all state management for this project. The main motivation behind this was to avoid passing many, many props throughout the application. In this sort of application it simplifies things a lot when compared to the normal React Hooks. Styling Styled Components make it very easy to style React applications in a more modular fashion and allow easier control over styles via JavaScript/TypeScript. Some regular css files are imported to index.html but those are mostly externally provided. For instance for react-datepicker to work properly they need to import one; Google Fonts and Font Awesome both require importing one as well to work offline. Icons Font Awesome is a fantastic resource for icons and while not many are actually used in this project it comes in handy. Routing React Router is used for routing between \"pages\", making the project a single web page React application. Passing data around between multiple pages would be much more complex. In addition React Router has the HashRouter which, while not being as advanced as the default BrowserRouter , makes it possible to use the forms as static files. This is needed for the offline version of the forms. PDF Generation jsPDF allows for easy generation and saving of the PDFs and jsPDF-AutoTable makes table generation extremely simple. One thing to note about these two packages: while they do work with TypeScript (especially jsPDF-AutoTable ) sometimes it can be a little weird to get it working properly. Read the docs thoroughly if you need to make any large changes.","title":"Tools"},{"location":"tools/#language","text":"This project was built from the ground up in TypeScript rather than JavaScript. This makes some aspects of development more tedious, but as projects grow larger they become easier to deal with especially when it comes to state management. Most other packages used in this project have great Typescript support (with the exception of jspdf ).","title":"Language"},{"location":"tools/#framework","text":"This project uses React which is a fantastic framework that is well suited to this type of application. These fairly complex data-heavy forms are extremely easy to manage with React's state management system.","title":"Framework"},{"location":"tools/#datepicker","text":"Note that React Datepicker provides the date selection component used on the Home page.","title":"Datepicker"},{"location":"tools/#state-management","text":"Redux Toolkit is used for almost all state management for this project. The main motivation behind this was to avoid passing many, many props throughout the application. In this sort of application it simplifies things a lot when compared to the normal React Hooks.","title":"State Management"},{"location":"tools/#styling","text":"Styled Components make it very easy to style React applications in a more modular fashion and allow easier control over styles via JavaScript/TypeScript. Some regular css files are imported to index.html but those are mostly externally provided. For instance for react-datepicker to work properly they need to import one; Google Fonts and Font Awesome both require importing one as well to work offline.","title":"Styling"},{"location":"tools/#icons","text":"Font Awesome is a fantastic resource for icons and while not many are actually used in this project it comes in handy.","title":"Icons"},{"location":"tools/#routing","text":"React Router is used for routing between \"pages\", making the project a single web page React application. Passing data around between multiple pages would be much more complex. In addition React Router has the HashRouter which, while not being as advanced as the default BrowserRouter , makes it possible to use the forms as static files. This is needed for the offline version of the forms.","title":"Routing"},{"location":"tools/#pdf-generation","text":"jsPDF allows for easy generation and saving of the PDFs and jsPDF-AutoTable makes table generation extremely simple. One thing to note about these two packages: while they do work with TypeScript (especially jsPDF-AutoTable ) sometimes it can be a little weird to get it working properly. Read the docs thoroughly if you need to make any large changes.","title":"PDF Generation"}]}